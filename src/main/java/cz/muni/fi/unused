
    /*
UNUSED:

// hladanie trashedCars pomocou joinov
// join approach to get the trashed cars is super slow, so using the pattern one (also count: 143865)
            EPStatement trashedCars2 = cepAdm.createEPL(
                "select s1.vid, s1.time, s2.time, s3.time, s4.time from stoppedCars.win:time(3 min) as s1 " +
                        "inner join stoppedCars.win:time(3 min) as s2 on s1.vid=s2.vid " +
                        "inner join stoppedCars.win:time(3 min) as s3 on s1.vid=s3.vid " +
                        "inner join stoppedCars.win:time(3 min) as s4 on s1.vid=s4.vid " +
                        "where s1.time + 30 =s2.time and s3.time=s2.time+30 and s4.time=s3.time+30 and s4.time<=s1.time+100");
        trashedCars2.addListener(new UpdateListener() {
            @Override
            public void update(EventBean[] newEvents, EventBean[] oldEvents) {
                System.out.println("blaaa: " + newEvents.length);
                System.out.print("vid: " + newEvents[0].get("s1.vid"));
                for (int i = 1; i < 5; i++) {
                    System.out.println(" " + newEvents[0].get("s"+i+".time") + " ");
                }
                System.out.println();
                trashedCarsCount[0]++;
            }
        });


        This keeps a 30 second window of unique (xway, segment, direction) triples which have a trashed car,
        and joins that with every new trashed car. If there is a match where the vids are different, it means there
        is an accident (we don't care how many cars were in the accident) and we send a new accident event.
        The downstream operators are supposed to keep a 30second window of the accidents stream.
        NEFUNGUJE - problem je ze on najprv vlozi novy event do prveho window, potom do joinovaneho a porovnava teda posledny event s poslednym
        EPStatement accidents = cepAdm.createEPL(
//                "insert into unfilteredAccidents select t1.vid, t2.vid, t1.xway as xway, t1.segment as segment, t1.direction as direction, t2.time as time from trashedCars.win:time(30 sec) as t1" +
//                "insert into accidents select distinct t1.xway as xway, t1.segment as segment, t1.direction as direction from trashedCars.win:time(30 sec) as t1" +
                "@Audit insert into accidents " +
                        "select t1.xway as xway, t1.segment as segment, t1.direction as direction " +
                        "from trashedCars.win:time(30 sec).std:unique(xway, segment, direction) as t1 " +
                        "inner join trashedCars.win:length(1) as t2 on t1.xway=t2.xway and t1.segment=t2.segment and t1.direction=t2.direction " +
                        "where t1.vid != t2.vid");
        accidents.addListener(new UpdateListener() {
            @Override
            public void update(EventBean[] newEvents, EventBean[] oldEvents) {
                accidentsCount[0]++;
                System.out.println("accideeeeent");
            }
        });



        // esper 2level aggregation http://esper.codehaus.org/tutorials/solution_patterns/solution_patterns.html#aggregate-4a to zaroven vyriesi to ze esper nema sliding window v zmysle kazdu minutu za poslednych 5 minut
        // IDEA pouzivat named windows? pouzivat contexty?
        // contexty mi v accidentoch nepomahaju, v tolls ta 2level aggr bude asi lepsia na distr
        // moze to byt ale o dost efektivnejsie kedze sa nebude uchovavat cely obsah window...
// minute segment statistics (to use in 2level aggregration)

        EPStatement minuteStats = cepAdm.createEPL("" +
                "insert into minuteStats " +
                "select xway, segment, direction, count(*) as cnt, avg(speed) as avgspd " +
                "from LRB(type=0).win:ext_timed_batch(time * 1000, 60 sec) " +
                "group by xway, segment, direction " +
                "having count(*) > 0");
        minuteStats.addListener(new UpdateListener() {
            @Override
            public void update(EventBean[] newEvents, EventBean[] oldEvents) {
                ArrayList<SegmentStatistic> s = new ArrayList<SegmentStatistic>(100);
                for (EventBean newEvent : newEvents) {
                    s.add(new SegmentStatistic(newEvent));
                }
                Collections.sort(s);
                System.out.println("oldStats: " +newEvents.length + " here be collection: " + s);
            }
        });







//// 2 level aggregation - working without the count being distinct and only from last minute
        EPStatement minuteStats = cepAdm.createEPL(
                "insert into segmentSt select xway, segment, direction, count(distinct vid) as count, avg(speed) as averageSpeed " +
                        "from LRB(type=0).win:ext_timed_batch(time * 1000, 5 sec) " +
//                        "from LRB(type=0).win:time_batch(60 sec) " +       // alternative
                        "group by xway, segment, direction ");

        // the five minute stats need to run AFTER the minute ones
        // to make the outputting start at the beginning, we send an empty minuteStats event at second 2 (see the datadriver loop)
        EPStatement fiveMinuteStats = cepAdm.createEPL(
                "insert into fiveMinuteStats select xway, segment, direction, sum(count) as count, avg(averageSpeed) as averageSpeed " +
                        "from segmentSt.win:time(4 min 30 sec) " +
                        "group by xway, segment, direction " +
                        "output snapshot every 60 seconds");
        /* TODO
          problems:
          1. if a minuteStats output is delayed by lets say 2 seconds (gc event for example), the fiveminute statement might miss it
              - one solution: group the minute statistics in a listener in a single object, and then in the fiveminute statement
          use length(5), also use 5 of those fiveminute statements to use length_batch(5), so that we get all 5 events in the
          listener... do the aggregates, post results
          */

        minuteStats.addListener(new StatisticsListener("MINUTE"));
        fiveMinuteStats.addListener(new StatisticsListener("FIVEMINUTE"));

        // add this to datadriver loop
                if (time == 1000) {
                    System.out.println("send empty segmentstatistic event");
                    cepRT.sendEvent(new SegmentStatistic(0, 0, 1, 0, 0));
                }
        // add this to esper configuration
        cepConfig.addEventType("segmentSt", SegmentStatistic.class.getName());

     */